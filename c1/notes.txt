>> 1-1
https://github.com/ZeroCho/react-nodebird/tree/master/toolkit
# 리액트에선 next.js, 뷰에선 nuxt.js였으나, next.js에서 많이 지원함
## nuxt.js처럼 동적 라우팅 가능
## API 라우트로 백엔드로 프론트엔드 서버에서 커버 가능
## 페이지 미리 빌드하는 기능 추가됨 -> 응답 속도가 빨라짐, 성능적 최적화됨
## 개발 로그도 자세히 나옴
## node 14버전 사용

# Ant Design도 바뀜

# API가 없으면 더미 데이터로 프론트엔드 개발자가 개발을 진행함

# 프레임워크 특성상 갖춰진 것 많으나, 자유도가 떨어짐 -> 서버 사이드 렌더링 기능이 제일 유용함

# 브라우저 - 프론트 서버 - 백 엔드 서버 - 데이터베이스 (SSR의 전통적인 방식)

# 리액트는 컴포넌트만 바뀌고, 실제 페이지는 안 바뀜 (SPA 방식 (CSR))
## 프론트엔드 서버는 JS, HTML, CSS, IMG만 전달함 -> 다음 실제 데이터는 백엔드에 요청해서 데이터를 가져옴


>> 1-2
# 질문 잘 하는 방법
## 라이브러리나 프레임워크만 가져다가 조립만 하면 됨 -> 남의 코드이므로, 에러 발생 시 해결이 어려움
## 에러가 났을 때, 회사에선 구글링, 스택오버플로우나 사수한테 질문함

# 나쁜 질문 안 하는 방법
## 온라인에선 질문해도 되나요를 묻지 않음 -> 이건 오프라인에서만
## 돌려서 질문하지 말 것
## 엉뚱한 곳에 질문하지 말 것
## 질문 제목을 구체적으로 달을 것
### 이메일 제목도 핵심 제목 내용을 적어야 함
## 온라인에선 스무 고개하지 말 것 -> 오프라인에서는 가능함
### 능동적으로 해야 함
## 질문할 때에는 코드를 보여주되, 포맷이 정상적인 코드를 제공해야 함
## 시행 착오한 내용을 말할 것
## 코드는 직접 짜달라고 요청하지 말 것
## OS나 버전 등이 중요함 -> 왜냐하면 특정 운영체제나 버전의 이슈일 수도 있기 때문임

# 배워가고 싶은 경우, 어떻게 에러를 해결하는 지 확인해볼 것
## 에러 메세지는 번역만 해도 대부분은 단서를 찾을 수 있음
## 에러 메세지가 길어도 되니, 전체 내용을 올릴 것 -> 전체 내용을 보는 것도 중요함 (stack trace)
## 온라인 상에서 에러 메세지를 요청할 때, 텍스트로 올릴 것

>> 1-3
# 전통 방식
## 브라우저에서 요청을 보내면 프론트 서버에서 백 엔드 서버는 데이터베이스로 데이터를 요청함
## 데이터베이스에서 백 엔드 서버로 데이터를 보내고, 백 엔드 서버에서 데이터를 프론트 서버로 전달하면 HTML과 데이터를 합쳐서 브라우저로 전달함
## 장점 : 화면에 전체가 한번에 그려지나 과정이 길어 로딩 속도가 많이 걸림 (3초 이내에 페이지를 보여주는 게 현재에선 중요함)

# 싱글 페이지 애플리케이션 (SPA) 방식
## 리액트나 뷰, 앵글러에선 브라우저에서 먼저 페이지를 하나 받은 다음, 로딩 창이 돌아갈 때 브라우저가 백 엔드 서버에 데이터를 요청해서 가져옴
## 장점 : 로딩 창을 먼저 보여주고, 그 사이에 시간을 벌어서 백 엔드 서버에서 브라우저에서 데이터를 가져옴 => 일단 화면에 뭐라도 보여줌
## 허나 전체적인 시간은 전통 방식과 유사하나, 오히려 시간이 더 걸릴 수 있음 => 변경되는 부분에 대한 화면까지 다 가져와야 하기 때문임

# 프로젝트에서 의사결정을 내릴 때, 어떤 페이지는 리액트를 안 쓰는 게 나을 수 있음
## 사용자 간 빠르게 인터렉션이 필요할 때, 리액트를 사용함

# 구글 검색 엔진은 리액트나 앵글러를 보면 SPA인지 알아차림, 국내의 어떤 검색 엔진은 미완성 페이지라고 판단하여 우선 순위를 내림
## 이에 대한 방안이 검색 엔진을 위해 서버 사이드 렌더링과 코드 스플리팅 기능을 통해 페이지에 필요한 코드만 제공한다.
### 이는 실무에선 꼭 적용하는 게 좋음 -> 간단한 페이지가 아닌 경우엔 반드시

# 프리 렌더는 검색 엔진을 알아차리고 검색 엔진일 때 완성된 HTML을 제공하고 일반적인 유저일 때 기존 리액트 방식으로 제공

# 서버 사이드는 첫 방문만 전통 방식으로 하고, 그 다음부턴 리액트 방식으로 제공하는 것 -> 하이브리드, 이벤트 발생할 때만 리액트 방식으로 함

# 넥스트는 언제 쓰지 않아도 되는가 -> 관리자 페이지는 반드시 필요하지 않음 (리액트로 만들어도 충분함)

# 넥스트를 사용하지 않고 리액트로 서버 사이드 렌더링하고 싶은 경우, 제로초의 reactGo 참조

>> 1-4
# 검색 엔진과 사용자가 접근하는 페이지를 구현할 때 넥스트가 매우 유용함

# 특정 주소로 들어갈 때 로딩 창이 없는 이유
## 리액트일 때, 데이터 없이 자바스크립트와 HTML을 받아옴 -> 로딩 창 발생
## 서버 사이드 렌더링이면 브라우저에서 첫 방문 페이지만 전통 방식으로 진행함
### 다른 페이지를 들어갈 때에는 데이터만 받아옴
### 넥스트는 프리 패칭을 통해 미리 클릭할만한 혹은 링크로 연결된 코드 스플리팅된 페이지를 미리 받아옴 -> 로딩 속도 향상, 데이터 캐싱도 가능함

# next 9 & ant design 4 & styled component 5

>> 1-5
# 노드 프로젝트는 package.json이 필요함
# 명령어 모음
- npm init (이름 : react-nodebird-front)
- npm i next@9
- npm i prop-types

# 넥스트에선 리액트를 임포트할 필요가 없음
## pages 폴더 내에선 넥스트가 인식하여 하나의 파일들을 개별적인 페이지로 만들어줌 -> 페이지 컴포넌트 (코드 스플리팅된 컴포넌트)
### 이 안에서만 코드 스플리팅을 자동으로 해줌

>> 1-6
# 넥스트에선 추가된 페이지를 인식 못 하는 경우가 있을 수도 있으며 이 때는 서버를 종료했다가 다시 키면 됨

# pages 폴더 내 다른 폴더를 만들 수 있음

# 동적으로 페이지 이름을 바꾸고 싶은 경우, [names].js 형태로 작성하면 됨

# 컴포넌트 재사용이나 불필요한 리렌더링을 막기 위해 나누는 경우,  components 폴더를 만들면 됨 (반드시 이름이 components일 필요는 없음)

>> 1-7
# 넥스트에선 리액트 핫 로더 기능을 지원함

# 개발 모드에선 페이지 전환 속도가 느릴 수 있음

# 명령어 모음
- npm i eslint -D  
- npm i eslint-plugin-import -D
- npm i eslint-plugin-react -D 
- npm i eslint-plugin-react-hooks -D 

# .eslintrc는 json 파일임
# 파일 내용
{
  "parserOptions": {
      "ecmaVersion": 2022,
      "sourceType": "module",
      "ecmaFeatures": {
        "jsx": true
      }
  },
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "extends": [
    "eslint:recommend",
    "plugin:react/recommend"
  ],
  "plugins": [
    "import",
    "react-hooks"
  ],
  "rules": {
    
  }
}

>> 1-8 
# 서버사이드 렌더링하려면 리액트 + 노드 (백엔드)가 필요함
## 노드 대신에 스프링, 장고, 루비온 레일 이런 거 다 됨
## 즉 리액트랑 서버가 1개가 필요함

# 머트리얼 디자인과 앤트 디자인, 부트스트랩 둘 다 선호 차이임
## 디자이너가 디자이너 시스템이 체계적으로 갖춰졌다면 그리드나 반응형 디자인과 같은 도움 없이 디자인을 꾸밀 수 있음

# 다이나믹 라우팅이 넥스트9에서 편해짐 -> 이 기능이 없어져서 커스텀 프론트 엔드 서버를 만들 필요 없이 다이나믹 라우팅과 API 라우팅이라는 기능도 추가됨

# 브라우저 - 백엔드간 요청에 CORS 설정이 필요함
## 서버 사이드 렌더링할 때, 백엔드와 프론트엔드 서버의 도메인이 다르기 때문에, 포트만 달라도 CORS가 걸림 -> 백엔드에서 설정해야 함, 프론트엔드에서도 쿠키에 with credentials도 설정해야 함
## 서버 사이드 렌더링이, 프론트 엔드와 브라우저 뿐만이 아닌 백엔드 서버, 데이터베이스까지 연관이 있음
## 브라우저, 프론트 서버 사이에는 CORS가 적용 안 되나, 프론트와 백엔드는 CORS가 적용됨
## 실무에선 서버 두 개로 하여 구축을 함

# CSR : 브라우저 - 프론트 서버 - 브라우저 -> 브라우저 - 백엔드 서버 - 브라우저
# SSR : 브라우저 - 프론트 서버 - 백 엔드 서버 - DB - 백 엔드 서버 - 프론트 서버 - 브라우저

# 코드 스플리팅은 JS 파일을 쪼개서 필요한 페이지에 대한 JS 파일만 받아오도록 함
## 브라우저에서 프론트 서버로 원래 CSR일 때 , 모든 화면이 다 담겨져 있음
## 리액트 특성상 한 번에 다 받아오는데 코드 스플리팅에는 특정 JS을 쪼개서 해당 페이지에만 내용만 받아옴
### 받은 이후엔 본래 백엔드 서버와 통신을 하나, 코드 스플리팅을 하면 페이지를 받아올 때마다 프론트 서버에 특정 페이지에 대한 부분적으로 요청을 함

# EJS 방식으로 서버사이드 렌더링을 해도 됨 -> 템플릿 엔진은 아무런 상관이 없음
## EJS와 리액트를 같이 사용함

# 퍼그 + 리액트, 노드 쪽 템플릿 엔진 => 넌적스, 퍼그, 트위그, 진자

# 가장 효율적으로 구현하는 게 좋음 -> 랜딩 페이지는 굳이 리액트로 구현할 필요가 없음
## 리액트의 주된 목적은 UX으로 웹 앱, 모바일 앱을 쓰는 것 같은 느낌을 줄 수 있음

# 서버 사이드 렌더링은 검색 엔진의 사용 여부에 따라 달라짐

# 몽고디비는 추천 안 함 -> 모든 서비스의 85%는 SQL 쓰는 게 나을 수 있음
## 기본적으로 웬만한 사이트는 관계성이 있음 -> SQL
## 몽고디비는 데이터 간 관계성이 없을 때 사용하는 게 그럴 때 사용하는 게 나을 수 있음

# 로딩을 없애는 이유로 서버사이드 렌더링 하는 게 좋음
## 서버에서 각 페이지 및 데이터를 캐싱할 수 있음 -> 매번 렌더링 하는 것이 아님

>> 1-9

